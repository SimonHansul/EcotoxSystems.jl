var documenterSearchIndex = {"docs":
[{"location":"#EcotoxSystems.jl","page":"EcotoxSystems.jl","title":"EcotoxSystems.jl","text":"","category":"section"},{"location":"#Quickstart","page":"EcotoxSystems.jl","title":"Quickstart","text":"","category":"section"},{"location":"","page":"EcotoxSystems.jl","title":"EcotoxSystems.jl","text":"To get acquainted with using EcotoxSystems.jl, you can use the default model and default parameters. <br>","category":"page"},{"location":"","page":"EcotoxSystems.jl","title":"EcotoxSystems.jl","text":"Let's start with simulating individual life-history based on the default parameters:","category":"page"},{"location":"","page":"EcotoxSystems.jl","title":"EcotoxSystems.jl","text":"p = deepcopy(EcotoxSystems.defaultparams)\np.glb.t_max = 21.\nsim = EcotoxSystems.ODE_simulator(p)\nfirst(sim, 5)","category":"page"},{"location":"","page":"EcotoxSystems.jl","title":"EcotoxSystems.jl","text":"Here, we first create a copy of the default parameters.  These contain two components:","category":"page"},{"location":"","page":"EcotoxSystems.jl","title":"EcotoxSystems.jl","text":"glb for global parameters. This includes simulation settings like the maximum simulated time-span, and forcings such as the food input rate dX_in.\nspc for species-specific parameters. For the default model, these are DEB-TKTD and some auxiliary parameters. ","category":"page"},{"location":"","page":"EcotoxSystems.jl","title":"EcotoxSystems.jl","text":"The second line, ","category":"page"},{"location":"","page":"EcotoxSystems.jl","title":"EcotoxSystems.jl","text":"p.glb.t_max = 21.","category":"page"},{"location":"","page":"EcotoxSystems.jl","title":"EcotoxSystems.jl","text":"adjusts the simulated time-span. <br> With ","category":"page"},{"location":"","page":"EcotoxSystems.jl","title":"EcotoxSystems.jl","text":"sim = EcotoxSystems.ODE_simulator(p)","category":"page"},{"location":"","page":"EcotoxSystems.jl","title":"EcotoxSystems.jl","text":", we then simulate the model. <br> ODE_simulator is the central function to execute models which are purely ODE-based. <br> The output `sim is a DataFrame containing all state variables over time. <br> Storing the solution in a DataFrame can be convenient, but, for simple models, consumes a considerable proportion of computation time.  It is possible to skip the conversion and retrieve the ODEsolution instead by setting returntype=EcoxSystems.odesol. <br>","category":"page"},{"location":"","page":"EcotoxSystems.jl","title":"EcotoxSystems.jl","text":"Instead of simulating the life-history of a single individual, we can also simulate population dynamics.  To do so for the default model, we need to adjust the global parameters,  set plausible value for the starvation parameters (which were irrelevant before),  and call IBM_simulator:","category":"page"},{"location":"","page":"EcotoxSystems.jl","title":"EcotoxSystems.jl","text":"using Distributions, ProgressMeter\n\np = deepcopy(EcotoxSystems.defaultparams)\n\n# adjusting global parameters\n\np.glb.t_max = 365. # simulated timespan [d]\np.glb.V_patch = 0.5 # simulated volume [L]\np.glb.dX_in = 10_000 # provide more food \n\n# adjusting species-level parameters\n\np.spc.Z = Truncated(Normal(1, 0.1), 0, Inf) # induce individual variability \np.spc.S_rel_crit = 0.66\np.spc.h_S = -log(0.5)\n\nsims = @replicates EcotoxSystems.IBM_simulator(p, showinfo = Inf) 10 # run replicated simulations\n","category":"page"},{"location":"","page":"EcotoxSystems.jl","title":"EcotoxSystems.jl","text":"To deviate from the default model, there are a number of components to tweak in order to fully specify the system:","category":"page"},{"location":"","page":"EcotoxSystems.jl","title":"EcotoxSystems.jl","text":"init_global_statevars: A function that initializes global state variables.\nglobal_ode!: ODE-portion of the dynamics of global states.\nglobal_rules!: Rule-based portion of the dynamics of global states. \ninit_individual_statevars: A function that initializes individual-level state variables. \nindividual_ode!: ODE-portion of the dynamics of individual-level states. \nindividual_rules!: Rule-based portion of the dynamics of individual-level states.\ngen_ind_params:  A function that translates species-specicif parameters spc into individual-level parameters ind. The default is generate_individual_params and is generic, apart from assuming that spc contains an entry for Z and propagate_zoom.","category":"page"},{"location":"#API","page":"EcotoxSystems.jl","title":"API","text":"","category":"section"},{"location":"","page":"EcotoxSystems.jl","title":"EcotoxSystems.jl","text":"Modules = [EcotoxSystems]","category":"page"},{"location":"#EcotoxSystems.defaultparams","page":"EcotoxSystems.jl","title":"EcotoxSystems.defaultparams","text":"Default parameter object\n\n\n\n\n\n","category":"constant"},{"location":"#EcotoxSystems.DEBODE!-NTuple{4, Any}","page":"EcotoxSystems.jl","title":"EcotoxSystems.DEBODE!","text":"DEB-ODE model with arbitrary number of stressors, assuming IA to compute combined effects. \n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.DEBkiss_individual!-NTuple{4, Any}","page":"EcotoxSystems.jl","title":"EcotoxSystems.DEBkiss_individual!","text":"Individual-level part of the DEB-ODE model with arbitrary number of stressors, assuming IA to compute combined effects.\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.DEBkiss_physiology!-NTuple{4, Any}","page":"EcotoxSystems.jl","title":"EcotoxSystems.DEBkiss_physiology!","text":"DEBkiss!(du, u, p, t)::Nothing\n\nDynamics of DEBkiss model with maturity and explicit simulation of resource dynamics.\n\nThe density of structure is ignored, and instead S^(2/3) is applied for surface-area scaling.  This affects the dimension of dI_max, but has no effect on the model dynamics.\n\nIf model output is to be compared to length data, a statistical weight-lenght relationship  has to be applied to the model output.\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.Euler!-Tuple{ComponentArrays.ComponentVector, ComponentArrays.ComponentVector, Real}","page":"EcotoxSystems.jl","title":"EcotoxSystems.Euler!","text":"Euler!(u::ComponentVector, du::ComponentVector, dt::Real)::Nothing\n\nApply Euler scheme to state variables.\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.IBM_simulator-Tuple{ComponentArrays.ComponentVector}","page":"EcotoxSystems.jl","title":"EcotoxSystems.IBM_simulator","text":"IBM_simulator(\n    p::ComponentVector; \n    global_ode! = DEBODE_global!,\n    global_rules! = default_global_rules!,\n    init_global_statevars = initialize_global_statevars,\n    individual_ode! = DEBkiss_individual!,\n    individual_rules! = default_individual_rules!,\n    init_individual_statevars = initialize_individual_statevars,\n    dt = 1/24, \n    saveat = 1,\n    record_individuals = true,\n    showinfo::Number = Inf\n)\n\nSimulate the individual-based version of the default model. \n\nusing EcotoxSystems\np = DEB.params()\nsim = DEB.IBMsimulator(p)\n\nFor explanation of arguments, see IndividualBasedModel.\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.ODE_simulator-Tuple{ComponentArrays.ComponentVector}","page":"EcotoxSystems.jl","title":"EcotoxSystems.ODE_simulator","text":"ODE_simulator(\n    p::ComponentVector; \n    alg = Tsit5(),\n    saveat = 1,\n    reltol = 1e-6,\n    model = DEBODE!,\n    statevars_init = initialize_statevars,\n    gen_ind_params = generate_individual_params,\n    param_links::Union{Nothing,NamedTuple} = nothing,  \n    callbacks = DEBODE_callbacks,\n    returntype::ReturnType = dataframe,\n    kwargs...\n)\n\nRun the model as ODE system.  This function is essentially a wrapper around OrdinaryDiffEq.solve with additional input and output processing.\n\nargs:\n\np: Parameters, given as component vector. \n\nAt least two components are given: glb for global parameters,  spc for species-level parameters. glb as to contain an entry t_max for the maximum simulation time.  spc has to contain entries Z and propagate_zoom for the zoom factor and the parameters which are affected by the zoom factor.\n\nkwargs:\n\nThe following kwargs are used internally by OrdinaryDiffEq.solve. See OrdinaryDiffEq documentation for more information.\n\nalg: ODE solving algorithm to use.. \nsaveat: Interval or time-points at which to save the solution. Default is 1.\nreltol: Relative tolerance of ODE solution, default is 1e-6.\nmodel: ODE system to solve. \ncallbacks: A callback set, i.e. pairs of conditions and events. Used to handle discontinuities.  \n\nIn addition we have some kwargs that are used to further process inputs and outputs: \n\nstatevars_init: Function with signature statevars_init(p) that defines initial state variables as component vector. Components typically match those in the parameter vector. \n`genindparams: Function that converts species-level parameters to individual-level parameters, for example by replacing parameters which are given as distributions with a random sample from the distribution. The inputs and outputs of this function should contain all components. \nreturntype: Indicating of how to return the result. Currently allowed are dataframe (complete solution converted to a DataFrame) and odesol (the ODE solution object as returned by OrdinaryDiffEq). Default is dataframe.\n\nRun a model as purely ODE-based system: \n\nusing EcotoxSystems\nsim = DEB.ODE_simulator(EcotoxSystems.defaultparams(p))\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.TKTD_mix_IA!-NTuple{4, Any}","page":"EcotoxSystems.jl","title":"EcotoxSystems.TKTD_mix_IA!","text":"function TKTD_mix_IA!(du, u, p, t)::Nothing\n\nMixture-TKTD for an arbitrary number of stressors, assuming Independent Action.\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.calc_SL_max-Tuple{ComponentArrays.ComponentVector}","page":"EcotoxSystems.jl","title":"EcotoxSystems.calc_SL_max","text":"calc_SL_max(spc::ComponentVector)::Float64\n\nCalculate maximum structural length slmax [m^(1/3)]\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.calc_S_max-Tuple{ComponentArrays.ComponentVector}","page":"EcotoxSystems.jl","title":"EcotoxSystems.calc_S_max","text":"calc_S_max(spc::ComponentVector)::Float64\n\nCalculate maximum structural mass smax [m]\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.clipneg-Tuple{Float64}","page":"EcotoxSystems.jl","title":"EcotoxSystems.clipneg","text":"Clip negative values at 0 as a continuous function, using sig.\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.dI_embryo-NTuple{4, Float64}","page":"EcotoxSystems.jl","title":"EcotoxSystems.dI_embryo","text":"dI_embryo(\n    embryo::Float64,\n    S::Float64,\n    dI_max_emb::Float64,\n    y_T::Float64\n    )::Float64\n\nResource ingestion by embryos, i.e. uptake of yolk/vitellus. \n\nArguments\n\nembryo: State variable indicating whether current state is embryonic\nS: Structural mass\ndI_max_emb: Maxmimum size-specific ingestion rate of embryos\ny_T: Temperature coefficient\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.dS-NTuple{6, Float64}","page":"EcotoxSystems.jl","title":"EcotoxSystems.dS","text":"dS(\n    kappa::Float64,\n    dA::Float64, \n    dM::Float64, \n    eta_SA::Float64,\n    y_G::Float64,\n    eta_AS::Float64\n    )::Float64\n\nStructural growth rate. \n\nArguments\n\nkappa: Allocation fraction to somatic growth and maintenance\ndA: Assimilation rate\ndM: Somatic maintenance rate \neta_SA: Growth efficiency (yield of somatic mass on assimilates)\ny_G: Relative response of growth efficiency\neta_SA: Shrinking efficiency\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.default_global_rules!-Tuple{Any}","page":"EcotoxSystems.jl","title":"EcotoxSystems.default_global_rules!","text":"default_global_rules!(m)\n\nGlobal rule-based portion of the default model. \n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.default_individual_rules!-Tuple{EcotoxSystems.AbstractDEBIndividual, EcotoxSystems.AbstractDEBIBM}","page":"EcotoxSystems.jl","title":"EcotoxSystems.default_individual_rules!","text":"default_individual_rules(a::AbstractDEBIndividual, m::AbstractDEBIBM)::Nothing\n\nDefines the default rule-based portion for DEBIndividuals. <br>\n\nThe event functions which are used as callbacks during ODE solving are here re-used to apply rules for life stage transitions.\n\nA crude rule for starvation mortality is implemented, applying a constant hazard rate of a certain relative amount of structural mass is lost.\n\nReproduction is assumed to occur in fixed time intervals, according to spc.tau_R.\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.exposure-Union{Tuple{R}, Tuple{Function, ComponentArrays.ComponentVector, VecOrMat{R}}} where R<:Real","page":"EcotoxSystems.jl","title":"EcotoxSystems.exposure","text":"exposure(\n    simulator::Function, \n    p::ComponentVector, \n    C_Wmat::Union{Vector{R},Matrix{R}}\n) where R <: Real\n\nSimulate constant chemical exposure with over an arbitrary number of treatments and chemical stressors, defined in C_Wmat. \n\nThe columns of C_W are stressors, the rows are treatments. <br> If C_W is supplied as a Vector, it is assumed that the elements represent different levels of single-stressor exposure. <br> That means, to simulate a single-stressor experiment with three treatments, do \n\nC_Wmat = [0., 1., 2,]\n\n, internally creating a 1 x 3 matrix with exposure concentrations 0, 1 and 2. \n\nA single treatment with multiple stressors can be defined as \n\nC_Wmat = [0 1 2;]\n\nHere, we would have three stressors with the simultaneous exposure concentrations 0,1,2. <br>\n\nDefining four treatments for two stressors looks like this:\n\nC_Wmat = [\n    0.0 0.0; \n    0.0 0.5; \n    1.0 0.0; \n    0.5 1.0\n    ]\n\nThis exposure matrix corresponds to a ray design with constant exposure ratios.\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.filter_individuals!-Tuple{EcotoxSystems.AbstractDEBIBM}","page":"EcotoxSystems.jl","title":"EcotoxSystems.filter_individuals!","text":"filter_individuals!(m::AbstractDEBIBM)\n\nRemove individuals which have been flagged to die after the current time-step. \n\nIndividuals for which the condition u.ind.cause_of_death == 0 applies are retained.\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.generate_individual_params-Tuple{ComponentArrays.ComponentVector}","page":"EcotoxSystems.jl","title":"EcotoxSystems.generate_individual_params","text":"generate_individual_params(p::ComponentVector; kwargs...)\n\nGenerate individual-specific parameter set from species-specific parameter set.\n\nIf a parameter entry is a distribution, a random sample is taken. \n\nThis also works for Vectors of distributions.  The kwargs need to be supplemented with additional components if there are more than just a global and an individual-level component.\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.get_global_statevars!-Tuple{EcotoxSystems.AbstractDEBIndividual, EcotoxSystems.AbstractDEBIBM}","page":"EcotoxSystems.jl","title":"EcotoxSystems.get_global_statevars!","text":"get_global_statevars!(a::AbstractDEBIndividual, m::AbstractDEBIBM)::Nothing\n\nRetrieve global state variables and derivatives for use in the individual-level model step.\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.groupedlineplot!-Tuple","page":"EcotoxSystems.jl","title":"EcotoxSystems.groupedlineplot!","text":"groupedlineplot(x, y, g, q; estimator)\n\nVersion of lineplot with additional grouping variable g.\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.groupedlineplot!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}","page":"EcotoxSystems.jl","title":"EcotoxSystems.groupedlineplot!","text":"groupedlineplot(x, y, g, q; estimator)\n\nVersion of lineplot with additional grouping variable g.\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.groupedlineplot-Tuple","page":"EcotoxSystems.jl","title":"EcotoxSystems.groupedlineplot","text":"groupedlineplot(x, y, g, q; estimator)\n\nVersion of lineplot with additional grouping variable g.\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.individual_step!-Tuple{EcotoxSystems.AbstractDEBIndividual, EcotoxSystems.AbstractDEBIBM}","page":"EcotoxSystems.jl","title":"EcotoxSystems.individual_step!","text":"individual_step!(a::Agent, m::Model)::Nothing\n\nThe individual-level model step follows a generic pattern:\n\nFirst the ODE-portion of the model is executed, and the corresponding state variables are updated using the Euler scheme. \n\nThen the rule-based portion of the model is executed. These are all the functions which cannot / should not be expressed as part of an ODE. At the minimum, this will include life stage transitions, reproduction and death of individuals. \n\nFor a spatially explicit model, movement should also most likely be part of the rule-based portion,  as well as functions which require direct information exchange between individuals.\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.initialize_global_statevars-Tuple{ComponentArrays.ComponentVector}","page":"EcotoxSystems.jl","title":"EcotoxSystems.initialize_global_statevars","text":"initialize_global_statevars(p::ComponentVector)\n\nFunction to initialize global state variables.  In the default model, these are the resource abundance X,  external chemical stressor concentration C_W and population size N. \n\nGlobal state variables can be extended, modified or replaced in the same way as individual-level state variables. \n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.initialize_individual_statevars-Tuple{ComponentArrays.ComponentVector}","page":"EcotoxSystems.jl","title":"EcotoxSystems.initialize_individual_statevars","text":"initialize_individual_statevars(\n    p::ComponentVector; \n    id = 1., \n    cohort = 0.)::ComponentVector\n\nThis function defines the individual-level state variables and their initial values for the default model. \n\np is a parameter vector containing all components which are relevant for this simulation (including global state varaiables).\n\nid is an individual's unique identifier in the IBM simulation. \n\ncohortis the index of the cohort an indvidiual belongs to in the IBM simulation (i.e. initial generation is cohort 0,  their offsrping is cohort 1, etc.)\n\nTo add state variables or overwrite the default initial value, one can define a wrapper around this function: \n\nusing ComponentArrays\n\ncustom_ind_statevars(p; kwargs...) = ComponentVector(\n    EcotoxSystems.initialize_individual_statevars(); \n    new_statevar = 0.\n    )\n\nFor IBM simulations, the new function custom_ind_statevars can be supplied as keyword-argument  init_individual_statevars to IBM_simulator:\n\nsim = IBM_simulator(p; init_individual_statevars = custom_ind_statevars)\n\nFor the ODE, simulator, the state variables for all components are initialized simultaneously,  and this function does not take any additional keyword-arguments: \n\ncustom_statevars(p) = ComponentVector( # state variables for some completely new model\n    glb = initialize_global_statevars(p),\n    spc = custom_ind_statevars(p)\n)\n\nAlternatively, the custom ComponentVector can of course be defined from scratch in the new initialization functions for state variables: \n\ncustom_statevars(p) = ComponentVector( # state variables for some completely new model\n    glb = ComponentVector(t_max = 10., C_W = 0.),\n    spc = ComponentVector(N = 1.)\n)\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.initialize_statevars-Tuple{ComponentArrays.ComponentVector}","page":"EcotoxSystems.jl","title":"EcotoxSystems.initialize_statevars","text":"initialize_statevars(p::ComponentVector)::ComponentVector\n\nFor initialization of ODE simulator, initialize the component vector of state variables, u, based on common oaraeter collection p.\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.k_J!-Tuple{ComponentArrays.ComponentVector}","page":"EcotoxSystems.jl","title":"EcotoxSystems.k_J!","text":"k_J!(spc::ComponentVector)::Nothing\n\nSet the maturity maintenance rate constant,  assuming that the cumulative investment into maturity maintenance  equals the cumulative investment into somatic maintenance (cf. DEBkiss book by Tjalling Jager).\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.lineplot!-Tuple","page":"EcotoxSystems.jl","title":"EcotoxSystems.lineplot!","text":"lineplot(x, y, q; estimator)\n\nPlot aggregated values of y over x. Similar to seaborn.lineplot. By default, the arithmetic mean of y for every value of x is plotted,  with 5th to 95th percentiles as ribbon.  The plotted percentile range can be controlled via the positional argument q, which is a two-element Tuple. The arithmetic mean can be replaced with another function via the estimator argument. \n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.lineplot!-Tuple{RecipesBase.AbstractPlot, Vararg{Any}}","page":"EcotoxSystems.jl","title":"EcotoxSystems.lineplot!","text":"lineplot(x, y, q; estimator)\n\nPlot aggregated values of y over x. Similar to seaborn.lineplot. By default, the arithmetic mean of y for every value of x is plotted,  with 5th to 95th percentiles as ribbon.  The plotted percentile range can be controlled via the positional argument q, which is a two-element Tuple. The arithmetic mean can be replaced with another function via the estimator argument. \n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.lineplot-Tuple","page":"EcotoxSystems.jl","title":"EcotoxSystems.lineplot","text":"lineplot(x, y, q; estimator)\n\nPlot aggregated values of y over x. Similar to seaborn.lineplot. By default, the arithmetic mean of y for every value of x is plotted,  with 5th to 95th percentiles as ribbon.  The plotted percentile range can be controlled via the positional argument q, which is a two-element Tuple. The arithmetic mean can be replaced with another function via the estimator argument. \n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.link_params!","page":"EcotoxSystems.jl","title":"EcotoxSystems.link_params!","text":"link_params!(p::ComponentVector, links::NamedTuple = (spc = linkfun,))::Nothing\n\nApply functions to link parameters. <br>\n\np: ComponentVector containing parameters\nlinks: Component-specific functions to define links between parameters. \n\nExamples\n\nWe can apply the link before running a simulation, in which case the link is applied to the spc component  (species-level parameters).-\n\n\n\nlink_ind_params!(p) = begin\n    p.k_J_emb = (1-p.kappa_emb)/p.kappa_emb * p.k_M_emb\nend\n\np = deepcopy(defaultparams)\nlink_params!(p, (spc = link_ind_params!,) # apply link ahead of simulation \n\nAlternatively, we provide the links as a keyword argument to ODE_simulator,  in which case the link is applied to the ind component. <br> This is useful if one of the parameters involved in the link is subject to individual variability,  and we need to update the link for each simulated individual. <br>\n\n\nsim = ODE_simulator(p, param_links = (ind = link_ind_params!,))\n\n\n\n\n\n","category":"function"},{"location":"#EcotoxSystems.model_step!-Tuple{EcotoxSystems.AbstractDEBIBM}","page":"EcotoxSystems.jl","title":"EcotoxSystems.model_step!","text":"model_step!(m::AbstractDEBIBM)::Nothing\n\nGeneric definition of an individual-based model step.\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.params-Tuple{}","page":"EcotoxSystems.jl","title":"EcotoxSystems.params","text":"params(;kwargs...) = ComponentVector(defaultparams; kwargs...)\n\nInitialize the default parameter set, modifying and/or adding parameter with kwargs. \n\nExamples\n\n\n# simulate the default parameters\np = params()\nsim = ODE_simulator(p)  \n\n# simulate the default parameters, but modify kappa\np = params(kappa = 0.5) \nsim = ODE_simulator\n\n# simulate the default parameters with individual variabilty in kappa\np = params(kappa = truncated(Normal(0.5, 0.1), 0, 1))\nsim = @replicates ODE_simulator(p) 10\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.record_global!-Tuple{EcotoxSystems.AbstractDEBIBM}","page":"EcotoxSystems.jl","title":"EcotoxSystems.record_global!","text":"record_global!(m::AbstractDEBIBM)::Nothing\n\nStore global state variables in m.global_record.\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.record_individual!-Tuple{EcotoxSystems.AbstractDEBIndividual, EcotoxSystems.AbstractDEBIBM}","page":"EcotoxSystems.jl","title":"EcotoxSystems.record_individual!","text":"record_individual!(a::AbstractDEBIndividual, m::AbstractDEBIBM)::Nothing\n\nStore individual-level state variables in m.individual_record.\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.relative_response-Union{Tuple{D}, Tuple{D, Vector{Symbol}, Symbol}} where D<:DataFrames.AbstractDataFrame","page":"EcotoxSystems.jl","title":"EcotoxSystems.relative_response","text":"relative_response(\n    sim::D, \n    response_vars::Vector{Symbol},\n    treatment_var::Symbol; \n    groupby_vars::Vector{Symbol} = Symbol[],\n    identify_control = minimum\n    ) where D <: AbstractDataFrame\n\nCalculate relative responses. \n\nargs:\n\nsim::AbstractDataFrame: results\nresponse_vars::Vector{Symbol}: response variables for which to calculate the relative responses\ntreatment_var::Symbol: Column indicating the treatment. Column values can be numerical or categorical, but identify_control kwarg has to be specified in the latter case\n\nkwargs:\n\ngroupby_vars::Vector{Symbol}: relative response will be conditioned on these variables (e.g. time, separate experiments...). Empty by default.\nidentify_control: function used to identify reference values from treatment_var. By default, this is minimum() (assuming that column values in treatment_var are numerical).\n\n\n\nExample\n\nusing MechanisticEffectModels.EcotoxSystems, MechanisticEffectModels.Utils\n\nsimfunct(x) = @replicates EcotoxSystems.simulator(x) 10\n\nsim = exposure(simfunct, Params(), [0., 100., 200.]) |>\nx -> relative_response(x, [:S, :H, :R]) # -> data frame will contain columns y_S, y_H, y_R for control-normalized values\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.replicates-Tuple{Function, ComponentArrays.ComponentVector, Int64}","page":"EcotoxSystems.jl","title":"EcotoxSystems.replicates","text":"replicates(simulator::Function, defaultparams::ComponentVector, nreps::Int64; kwargs...)\n\nPerform replicated runs of simulator with parameters defaultparams (simulator(defaultparams) has to be a valid function call).  Analogous to @replicates, but a bit more flexible.\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.set_global_statevars!-Tuple{EcotoxSystems.AbstractDEBIBM, EcotoxSystems.AbstractDEBIndividual}","page":"EcotoxSystems.jl","title":"EcotoxSystems.set_global_statevars!","text":"set_global_statevars!(m::AbstractDEBIBM, a::AbstractDEBIndividual)::Nothing\n\nUpdate global state variables and derivatives based on individual-level model step.\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.sig-NTuple{4, Float64}","page":"EcotoxSystems.jl","title":"EcotoxSystems.sig","text":"sig(\n    x::Real, \n    x_thr::Real,\n    y_left::Real, \n    y_right::Real; \n    beta::Real = 30\n    )::Real\n\nSigmoid switch function.  Used to replace simple if-statements with a continuous function in ODE models. \n\ny_left and y_right are the function values left and right of the threshold x_thr.\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.texposure-Tuple{Function, ComponentArrays.ComponentVector, Vector{Float64}}","page":"EcotoxSystems.jl","title":"EcotoxSystems.texposure","text":"Threaded version of exposure().\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.treplicates-Tuple{Function, ComponentArrays.ComponentVector, Int64}","page":"EcotoxSystems.jl","title":"EcotoxSystems.treplicates","text":"treplicates(\n    simulator::Function, \n    defaultparams::ComponentVector, \n    nreps::Int64; \n    kwargs...)\n\nMulti-threaded version of replicates. \n\nOnly useful if Julia has been started with multiple threads. \n\nTo check the number of threads, run  using Base.Threads; Threads.nthreads().\n\nIn VSCode, you can use the entry \"julia.NumThreads\" in settings.json to set the default number of threads  (searching for \"julia threads\" in the preferences will lead you there). \n\nCheck the Multi-threading documentation  for more information.\n\n\n\n\n\n","category":"method"},{"location":"#EcotoxSystems.@replicates-Tuple{Expr, Int64}","page":"EcotoxSystems.jl","title":"EcotoxSystems.@replicates","text":"@replicates(simcall::Expr, nreps::Int64)\n\nPerform replicated runs of simcall, where simcall is a call to a simulator function. \n\nExample:\n\n    spc = SpeciesParams(Z = Truncated(Normal(1, 0.1), 0, Inf)) # initialize default parameters with variable zoom factor\n    sim = @replicates MechanisticEffectModels.simulator(Params(spc = spc))) 10 # execute replicated runs to simulator\n\nIn this case, sim will contain the output of 10 replicated simulations. For each replicate, the zoom factor is sampled from a truncated Normal distribution.  sim contains an additional column replicate.\n\n\n\n\n\n","category":"macro"}]
}
